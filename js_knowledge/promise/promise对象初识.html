<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
        /**
         * promise 对象是一个代理对象（代理一个值），被代理的值在 promise 对象创建时可能是未知的；
         * 它允许你为异步代码执行结果的 成功和失败 分别绑定相应的处理方法（handlers）；
         * 这让异步方法可以像同步方法那样返回值，但是并非立即返回执行的结果，因为毕竟执行的是异步代码；
         * 因此，他会返回一个 promise 对象，如前所说，他是一个代理的对象，代理了最终返回的值，可以在后期使用
         */

        // 初始化 promise，构造函数的参数
        var promise = new Promise(executor);

        /**
         * executor 是一个可执行函数，包含两个参数，resolve 和 reject，executor 函数会在 promise 对象
         * 初始化执行，并返回一个 promise 实例对象，resolve 句柄用于解决异步结果正确时候处理 promise，
         * 而 reject 句柄用于解决异步结果出错时处理 promise，启动异步处理之后，成功的则交给 resolve，
         * 失败的则会抛给 reject 处理；
         *
         * 在异步处理的过程中，promise 一共有三种状态：
         *     pending：初始状态，未履行或拒绝
         *     fulfilled：意味着操作成功完成
         *     rejected：意味着操作失败。
         * 我们通过初始化返回的 promise 实例对象的 then 方法添加之后的异步操作，通过 executor 中的业务逻辑，
         * 如果是 resolve 会进入成功的回调，reject 会进入失败的回调；
         */

        var promise = new Promise(function(resolve, reject) {
            // 业务逻辑
            resolve('success')
        });
        promise.then(function(result) {
            console.log(result);
            return result;
        }).then(function() {
            console.log('resolve')
        })

        /**
         * 初始化 promise 对象之后，resolve 或 reject 操作，then 接口中的函数会接收到结果，then 方法可以接受
         * 两个回调函数作为参数。第一个回调函数是 promise 对象的状态变为 resolved 时调用。第二个回调函数是 promise
         * 对象的状态变为 reject 时调用。其中第二个函数时可选的，不一定要提供。这两个函数都接受 promise 对象传出的值
         * 作为参数。
         */

        // 当异步操作失败以后，会进入失败回调
        new Promise(function(resolve, reject) {
            reject(new Error('ddd'));
        }).then(function(v) {
            console.log('v') //不会被调用
        }, function(e) {
            console.log(e)
        });

        var promise = new Promise(function(resolve, reject) {
            // 异步操作业务逻辑
            resolve('result');
            // reject(error);
        });
        promise.then(function() {
            //success
        }, function(error) {
            // failure
        })

        /**
         * 当然也可以不用这个方式进入捕捉失败异常，可以使用 catch 方式，promise.prototype.catch
         * 添加一个否定（rejection）回调到当前 promise，返回一个新的 promise。如果这个回调被调用，
         * 新 promise 将以他的返回值来 resolve，否则如果当前 promise 进入 fulfilled 状态，则以
         * 当前 promise 的肯定结果作为新 promise 的肯定结果
         */

        var p1 = new Promise(function(resolve, reject) {
            resolve('success');
        });

        p1.then(function(value) {
            console.log(value);
            throw 'no';
        }).catch(function(e) {
            console.log(e); // no
        }).then(function() {
            console.log('after a catch the chain is restored');
        }, function() {
            console.log('not fired due to the catch');
        });

        /**
         * 另外我们应该要知道，then 参数可以是一个或者两个可执行函数，可执行函数或不接受参数；当没有
         * resolve 而是 reject，或者说状态不是 fulfilled 而是 rejected，这个时候如果其后的 then 方法
         * 只有一个可执行函数作为参数，是无法捕捉错误或异常的，解决方式有两种，
         * 其一：明确写好两个可执行函数作为参数
         */

        new Promise(function(resolve, reject) {
            reject(new Error('ddd'));
        }).then(function(v) {
            console.log(v); //不会被调用
        }, function(e) {
            console.log(e);
        })

        /**
         * 其二：如果只想有一个参数，那就使用 promise 的 catch 方法进行捕获：
         */

        var promise = new Promise(function(resolve, reject) {
            throw New Error('ddd');
        });

        promise.then(function(result) {
            // 操作
        }).catch(function(error) {
            console.error(error);
        });
    </script>
</body>

</html>
